# ë¹„êµ í†µê³„ êµ¬í˜„ ë°©ì•ˆ (í”„ë¡œí† íƒ€ì…)

## ğŸ“‹ ê°œìš”

**ëª©í‘œ**: í˜„ì¬ ìƒ˜í”Œ ë°ì´í„°(`all_sample_rounds.json`)ë¥¼ í™œìš©í•˜ì—¬ ë¹„êµ í†µê³„ ê¸°ëŠ¥ êµ¬í˜„

**ì ‘ê·¼ ë°©ë²•**: 
- ìƒ˜í”Œ ë°ì´í„°ì˜ ëª¨ë“  ë¼ìš´ë“œë¥¼ ì§‘ê³„í•˜ì—¬ ë²¤ì¹˜ë§ˆí¬ ìƒì„±
- ì‚¬ìš©ìë³„ë¡œ ë°ì´í„°ë¥¼ ë¶„ë¦¬í•˜ì—¬ ë‹¤ì–‘ì„± í™•ë³´
- ì‹¤ì‹œê°„ ê³„ì‚° (ë³„ë„ JSON íŒŒì¼ ë¶ˆí•„ìš”)

---

## ğŸ¯ êµ¬í˜„ ì „ëµ

### 1. ìƒ˜í”Œ ë°ì´í„° ë¶„ì„

í˜„ì¬ `all_sample_rounds.json`ì—ëŠ” ì—¬ëŸ¬ ë¼ìš´ë“œ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ í™œìš©í•˜ì—¬:

1. **ì „ì²´ ë¼ìš´ë“œ ì§‘ê³„** â†’ ì „ì²´ í‰ê·  ê³„ì‚°
2. **ìƒìœ„/í•˜ìœ„ êµ¬ë¶„** â†’ í¼ì„¼íƒ€ì¼ ê³„ì‚°
3. **ê°€ìƒ ì‚¬ìš©ì ìƒì„±** â†’ ë¼ìš´ë“œë¥¼ ì—¬ëŸ¬ ì‚¬ìš©ìì—ê²Œ ë¶„ì‚°

### 2. ë°ì´í„° êµ¬ì¡°

```dart
class BenchmarkStats {
  final AggregateStats overall;      // ì „ì²´ í‰ê· 
  final AggregateStats top10;        // ìƒìœ„ 10%
  final AggregateStats bottom10;     // í•˜ìœ„ 10%
  
  // ì‚¬ìš©ì í¼ì„¼íƒ€ì¼ ê³„ì‚°ìš©
  final List<double> scoreDistribution;
  final List<double> fairwayDistribution;
  final List<double> driverDistanceDistribution;
}

class AggregateStats {
  final double averageScore;
  final double fairwayAccuracy;
  final double girPercentage;
  final double averagePutts;
  final double driverDistance;
  final double threePuttRate;
  final Map<String, double> puttingByDistance;
}
```

---

## ğŸ› ï¸ êµ¬í˜„ ë‹¨ê³„

### Step 1: BenchmarkRepository ìƒì„±

```dart
// lib/repositories/benchmark_repository.dart

class BenchmarkRepository {
  /// ëª¨ë“  ë¼ìš´ë“œì—ì„œ ë²¤ì¹˜ë§ˆí¬ í†µê³„ ê³„ì‚°
  BenchmarkStats calculateBenchmark(List<Round> allRounds) {
    if (allRounds.isEmpty) {
      return BenchmarkStats.empty();
    }
    
    // 1. ì „ì²´ í†µê³„ ê³„ì‚°
    final overall = _calculateAggregateStats(allRounds);
    
    // 2. ìŠ¤ì½”ì–´ ê¸°ì¤€ ì •ë ¬
    final sortedByScore = List<Round>.from(allRounds)
      ..sort((a, b) => a.totalScore.compareTo(b.totalScore));
    
    // 3. ìƒìœ„ 10% ë¼ìš´ë“œ
    final top10Count = (allRounds.length * 0.1).ceil();
    final top10Rounds = sortedByScore.take(top10Count).toList();
    final top10 = _calculateAggregateStats(top10Rounds);
    
    // 4. í•˜ìœ„ 10% ë¼ìš´ë“œ
    final bottom10Rounds = sortedByScore.reversed.take(top10Count).toList();
    final bottom10 = _calculateAggregateStats(bottom10Rounds);
    
    // 5. ë¶„í¬ ë°ì´í„° ìƒì„±
    final distributions = _createDistributions(allRounds);
    
    return BenchmarkStats(
      overall: overall,
      top10: top10,
      bottom10: bottom10,
      scoreDistribution: distributions['score']!,
      fairwayDistribution: distributions['fairway']!,
      driverDistanceDistribution: distributions['driver']!,
    );
  }
  
  /// ì§‘ê³„ í†µê³„ ê³„ì‚°
  AggregateStats _calculateAggregateStats(List<Round> rounds) {
    final scores = rounds.map((r) => r.totalScore.toDouble()).toList();
    final fairways = rounds.map((r) => 
      r.fairwaysHit / r.fairwaysAttempted * 100
    ).toList();
    final girs = rounds.map((r) => 
      r.greensInRegulation / 18.0 * 100
    ).toList();
    final putts = rounds.map((r) => r.totalPutts.toDouble()).toList();
    
    // ë“œë¼ì´ë²„ ìƒ· ì¶”ì¶œ
    final driverShots = rounds
      .expand((r) => r.holes)
      .expand((h) => h.shots)
      .where((s) => s.clubType == 'CLUB_D' && !s.isMulligan)
      .toList();
    
    final driverDistances = driverShots
      .where((s) => s.totalDistance != null)
      .map((s) => s.totalDistance!)
      .toList();
    
    // í¼íŒ… ì„±ê³µë¥  ê³„ì‚°
    final puttingByDistance = _calculatePuttingSuccessRates(rounds);
    
    // 3í¼íŠ¸ìœ¨ ê³„ì‚°
    final threePuttCount = rounds
      .expand((r) => r.holes)
      .where((h) => h.putts >= 3)
      .length;
    final totalHoles = rounds.length * 18;
    final threePuttRate = (threePuttCount / totalHoles) * 100;
    
    return AggregateStats(
      averageScore: _average(scores),
      fairwayAccuracy: _average(fairways),
      girPercentage: _average(girs),
      averagePutts: _average(putts),
      driverDistance: driverDistances.isEmpty ? 0 : _average(driverDistances),
      threePuttRate: threePuttRate,
      puttingByDistance: puttingByDistance,
    );
  }
  
  /// í¼íŒ… ê±°ë¦¬ë³„ ì„±ê³µë¥  ê³„ì‚°
  Map<String, double> _calculatePuttingSuccessRates(List<Round> rounds) {
    final puttsByDistance = <String, List<bool>>{
      '0-1m': [],
      '1-3m': [],
      '3-5m': [],
      '5-10m': [],
      '10m+': [],
    };
    
    for (var round in rounds) {
      for (var hole in round.holes) {
        for (var shot in hole.shots) {
          if (shot.isPutt && shot.puttLength != null) {
            final distance = shot.puttLength!;
            final made = shot.puttMade;
            
            if (distance <= 1) {
              puttsByDistance['0-1m']!.add(made);
            } else if (distance <= 3) {
              puttsByDistance['1-3m']!.add(made);
            } else if (distance <= 5) {
              puttsByDistance['3-5m']!.add(made);
            } else if (distance <= 10) {
              puttsByDistance['5-10m']!.add(made);
            } else {
              puttsByDistance['10m+']!.add(made);
            }
          }
        }
      }
    }
    
    return puttsByDistance.map((key, putts) {
      if (putts.isEmpty) return MapEntry(key, 0.0);
      final successCount = putts.where((made) => made).length;
      return MapEntry(key, (successCount / putts.length) * 100);
    });
  }
  
  /// ë¶„í¬ ë°ì´í„° ìƒì„± (í¼ì„¼íƒ€ì¼ ê³„ì‚°ìš©)
  Map<String, List<double>> _createDistributions(List<Round> rounds) {
    final scores = rounds.map((r) => r.totalScore.toDouble()).toList()..sort();
    
    final fairways = rounds
      .map((r) => r.fairwaysHit / r.fairwaysAttempted * 100)
      .toList()..sort();
    
    final driverDistances = rounds
      .expand((r) => r.holes)
      .expand((h) => h.shots)
      .where((s) => s.clubType == 'CLUB_D' && s.totalDistance != null)
      .map((s) => s.totalDistance!)
      .toList()..sort();
    
    return {
      'score': scores,
      'fairway': fairways,
      'driver': driverDistances,
    };
  }
  
  /// í¼ì„¼íƒ€ì¼ ê³„ì‚°
  int calculatePercentile(double userValue, List<double> distribution) {
    if (distribution.isEmpty) return 50;
    
    int betterCount = 0;
    for (var value in distribution) {
      if (userValue < value) betterCount++; // ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ (ìŠ¤ì½”ì–´)
    }
    
    return (betterCount * 100 / distribution.length).round();
  }
  
  /// í‰ê·  ê³„ì‚° í—¬í¼
  double _average(List<double> values) {
    if (values.isEmpty) return 0;
    return values.reduce((a, b) => a + b) / values.length;
  }
}
```

### Step 2: Provider ì„¤ì •

```dart
// lib/viewmodels/providers.dart

// BenchmarkRepository Provider
final benchmarkRepositoryProvider = Provider<BenchmarkRepository>((ref) {
  return BenchmarkRepository();
});

// ë²¤ì¹˜ë§ˆí¬ í†µê³„ Provider
final benchmarkStatsProvider = Provider<BenchmarkStats>((ref) {
  final rounds = ref.watch(roundsProvider).value ?? [];
  final repo = ref.watch(benchmarkRepositoryProvider);
  
  return repo.calculateBenchmark(rounds);
});

// ì‚¬ìš©ì í¼ì„¼íƒ€ì¼ Provider
final userPercentilesProvider = Provider<Map<String, int>>((ref) {
  final benchmark = ref.watch(benchmarkStatsProvider);
  final userStats = ref.watch(statsProvider).value;
  final repo = ref.watch(benchmarkRepositoryProvider);
  
  if (userStats == null) return {};
  
  return {
    'score': repo.calculatePercentile(
      userStats.averageScore,
      benchmark.scoreDistribution,
    ),
    'fairway': 100 - repo.calculatePercentile(
      userStats.fairwayAccuracy,
      benchmark.fairwayDistribution,
    ), // ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ
    'driverDistance': 100 - repo.calculatePercentile(
      userStats.averageDriverDistance ?? 0,
      benchmark.driverDistanceDistribution,
    ),
  };
});
```

### Step 3: ë¹„êµ ìœ„ì ¯ ìƒì„±

```dart
// lib/views/widgets/comparison_card.dart

class ComparisonCard extends ConsumerWidget {
  final String title;
  final double userValue;
  final String metric;
  final String unit;
  
  const ComparisonCard({
    required this.title,
    required this.userValue,
    required this.metric,
    this.unit = '',
  });
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final benchmark = ref.watch(benchmarkStatsProvider);
    final percentiles = ref.watch(userPercentilesProvider);
    
    final benchmarkValue = _getBenchmarkValue(benchmark, metric);
    final percentile = percentiles[metric] ?? 50;
    final difference = userValue - benchmarkValue;
    
    return Card(
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(title, style: TextStyle(fontSize: 14, color: Colors.grey)),
            SizedBox(height: 8),
            Text(
              '${userValue.toStringAsFixed(1)}$unit',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Divider(),
            SizedBox(height: 8),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('ì „ì²´ í‰ê· :', style: TextStyle(fontSize: 12)),
                Text(
                  '${benchmarkValue.toStringAsFixed(1)}$unit',
                  style: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
                ),
              ],
            ),
            SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('ì°¨ì´:', style: TextStyle(fontSize: 12)),
                Text(
                  '${difference > 0 ? '+' : ''}${difference.toStringAsFixed(1)}$unit',
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                    color: _getDifferenceColor(difference, metric),
                  ),
                ),
              ],
            ),
            SizedBox(height: 8),
            _buildPercentileBar(percentile),
          ],
        ),
      ),
    );
  }
  
  Widget _buildPercentileBar(int percentile) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'ìƒìœ„ $percentile%',
          style: TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
        ),
        SizedBox(height: 4),
        LinearProgressIndicator(
          value: (100 - percentile) / 100,
          backgroundColor: Colors.grey[300],
          valueColor: AlwaysStoppedAnimation(_getPercentileColor(percentile)),
        ),
      ],
    );
  }
  
  Color _getDifferenceColor(double diff, String metric) {
    // ìŠ¤ì½”ì–´ëŠ” ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ
    if (metric == 'score') {
      return diff < 0 ? Colors.green : Colors.orange;
    }
    // ë‚˜ë¨¸ì§€ëŠ” ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ
    return diff > 0 ? Colors.green : Colors.orange;
  }
  
  Color _getPercentileColor(int percentile) {
    if (percentile <= 10) return Colors.green;
    if (percentile <= 30) return Colors.lightGreen;
    if (percentile <= 50) return Colors.orange;
    return Colors.red;
  }
  
  double _getBenchmarkValue(BenchmarkStats benchmark, String metric) {
    switch (metric) {
      case 'score':
        return benchmark.overall.averageScore;
      case 'fairway':
        return benchmark.overall.fairwayAccuracy;
      case 'gir':
        return benchmark.overall.girPercentage;
      case 'putts':
        return benchmark.overall.averagePutts;
      case 'driverDistance':
        return benchmark.overall.driverDistance;
      default:
        return 0;
    }
  }
}
```

---

## ğŸ“Š ì‚¬ìš© ì˜ˆì‹œ

### ëŒ€ì‹œë³´ë“œì—ì„œ ì‚¬ìš©

```dart
// lib/views/dashboard_screen.dart

class DashboardScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final stats = ref.watch(statsProvider).value;
    
    return Scaffold(
      body: ListView(
        children: [
          // ê¸°ì¡´ í†µê³„ ì¹´ë“œë“¤
          StatCard(...),
          
          // ë¹„êµ ì„¹ì…˜
          Padding(
            padding: EdgeInsets.all(16),
            child: Text(
              'ë‹¤ë¥¸ ì‚¬ìš©ìì™€ ë¹„êµ',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
          
          ComparisonCard(
            title: 'í‰ê·  ìŠ¤ì½”ì–´',
            userValue: stats?.averageScore ?? 0,
            metric: 'score',
          ),
          
          ComparisonCard(
            title: 'í˜ì–´ì›¨ì´ ì ì¤‘ë¥ ',
            userValue: stats?.fairwayAccuracy ?? 0,
            metric: 'fairway',
            unit: '%',
          ),
        ],
      ),
    );
  }
}
```

---

## âœ… ì¥ì 

1. **ì¶”ê°€ ë°ì´í„° ë¶ˆí•„ìš”**: í˜„ì¬ ìƒ˜í”Œ ë°ì´í„°ë§Œìœ¼ë¡œ ì‘ë™
2. **ì‹¤ì‹œê°„ ê³„ì‚°**: ë°ì´í„° ë³€ê²½ ì‹œ ìë™ ì—…ë°ì´íŠ¸
3. **ê°„ë‹¨í•œ êµ¬í˜„**: ë³„ë„ íŒŒì¼ ìƒì„±/ê´€ë¦¬ ë¶ˆí•„ìš”
4. **í”„ë¡œí† íƒ€ì…ì— ì í•©**: ë¹ ë¥¸ ê°œë°œ ë° í…ŒìŠ¤íŠ¸ ê°€ëŠ¥

## âš ï¸ ì œí•œì‚¬í•­

1. **ë‹¤ì–‘ì„± ë¶€ì¡±**: ìƒ˜í”Œ ë°ì´í„°ê°€ ì œí•œì 
2. **ì„±ëŠ¥**: ë§¤ë²ˆ ê³„ì‚° (ìºì‹±ìœ¼ë¡œ í•´ê²° ê°€ëŠ¥)
3. **í˜„ì‹¤ì„±**: ì‹¤ì œ ì‚¬ìš©ì ë¶„í¬ì™€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ

í•˜ì§€ë§Œ í”„ë¡œí† íƒ€ì… ëª©ì ìœ¼ë¡œëŠ” ì¶©ë¶„í•©ë‹ˆë‹¤!

---

**ì‘ì„±ì¼**: 2025-11-28  
**ë²„ì „**: 1.0 (í”„ë¡œí† íƒ€ì…ìš©)
